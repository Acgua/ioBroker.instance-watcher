{
  "version": 3,
  "sources": ["../../src/lib/methods.ts"],
  "sourcesContent": ["/**\n * Methods and Tools\n * @desc    Methods and Tools\n * @author  Acgua <https://github.com/Acgua/ioBroker.instance-watcher>\n * @license Apache License 2.0\n *\n * ----------------------------------------------------------------------------------------\n * How to implement this file in main.ts (see also https://stackoverflow.com/a/58459668)\n * ----------------------------------------------------------------------------------------\n *  1. Add \"this: InstanceWatcher\" as first function parameter if you need access to \"this\"\n *       -> no need to provide this parameter when calling the method, though!\n *  1. Add line like \"import { err2Str, isEmpty } from './lib/methods';\"\n *  2. Add keyword \"export\" before \"class InstanceWatcher extends utils.Adapter\"\n *  3. class InstanceWatcher: for each method, add line like: \"public isEmpty = isEmpty.bind(this);\"\n *           Note: use \"private isEmpty...\" and not \"public\", if you do not need to access method from this file\n */\nimport { InstanceWatcher } from '../main';\n// import { IInstance } from './interfaces';\n\n/**\n * Turn adapter instance on/off\n * TO DO: Unbedingt noch ausf\u00FChrlich testen!\n * @param id - Instance Id, e.g. 'sonos.0'\n * @param flag - true to turn on or restart (if running), false to turn off\n * @returns true if successful, false if not.\n */\nexport async function asyncInstanceOnOff(this: InstanceWatcher, id: string, flag: true | false): Promise<true | false> {\n    try {\n        // If running type is schedule, we will switch off adapter first, then turn on.\n        if (this._inst.objs[id].mode === 'daemon') {\n            await this.setForeignStateAsync(`system.adapter.${id}.alive`, { val: flag, ack: false });\n            this.log.debug(`Adapter instance ${id} (${this._inst.objs[id].mode}) ${flag ? ' turned on.' : ' turned off.'}`);\n            return true;\n        } else if (this._inst.objs[id].mode === 'schedule') {\n            if (flag === false || this._inst.objs[id].enabled) {\n                // Falls instance should be turned off or the schedule adapter is enabled: turn off before\n                await this.setForeignStateAsync(`system.adapter.${id}.alive`, { val: false, ack: false });\n                this.log.debug(`Adapter instance ${id} (${this._inst.objs[id].mode}) turned off.`);\n            }\n            if (flag) {\n                // Einschalten\n                if (this._inst.objs[id].enabled) await this.wait(3000); // wait if was enabled, as turned off before.\n                await this.setForeignStateAsync(`system.adapter.${id}.alive`, { val: true, ack: false });\n                this.log.debug(`Adapter instance ${id} (${this._inst.objs[id].mode}) turned on.`);\n            }\n            return true;\n        } else {\n            this.log.warn(`Running mode '${this._inst.objs[id].mode}' of adapter '${id}' is not yet supported!`);\n            return false;\n        }\n    } catch (e) {\n        this.log.error(this.err2Str(e));\n        return false;\n    }\n}\n\n/**\n * Convert error to string\n * @param {*} error - any kind of thrown error\n * @returns string\n */\nexport function err2Str(error: any): string {\n    if (error instanceof Error) {\n        if (error.stack) return error.stack;\n        if (error.message) return error.message;\n        return JSON.stringify(error);\n    } else {\n        if (typeof error === 'string') return error;\n        return JSON.stringify(error);\n    }\n}\n\n/**\n * Convert date/time to a local ISO string\n * Required as toISOString() uses UTC +0 (Zulu) as time zone.\n * https://stackoverflow.com/questions/10830357/\n * @param   date    Date object\n * @returns string like \"2015-01-26T06:40:36.181\"\n */\nexport function dateToLocalIsoString(date: Date): string {\n    const timezoneOffset = date.getTimezoneOffset() * 60000; //offset in milliseconds\n    return new Date(date.getTime() - timezoneOffset).toISOString().slice(0, -1);\n}\n\n/**\n * Checks if an operand (variable, constant, object, ...) is considered as empty.\n * - empty:     undefined; null; string|array|object, stringified and only with white space(s), and/or `><[]{}`\n * - NOT empty: not matching anything above; any function; boolean false; number -1\n * inspired by helper.js from SmartControl adapter\n */\nexport function isEmpty(toCheck: any): true | false {\n    if (toCheck === null || typeof toCheck === 'undefined') return true;\n    if (typeof toCheck === 'function') return false;\n    let x = JSON.stringify(toCheck);\n    x = x.replace(/\\s+/g, ''); // white space(s)\n    x = x.replace(/\"+/g, ''); // \"\n    x = x.replace(/'+/g, ''); // '\n    x = x.replace(/\\[+/g, ''); // [\n    x = x.replace(/\\]+/g, ''); // ]\n    x = x.replace(/\\{+/g, ''); // {\n    x = x.replace(/\\}+/g, ''); // }\n    return x === '' ? true : false;\n}\n\n/**\n * async wait/pause\n * Actually not needed since a single line, but for the sake of using wait more easily\n * @param {number} ms - number of milliseconds to wait\n */\nexport async function wait(this: InstanceWatcher, ms: number): Promise<void> {\n    try {\n        await new Promise((w) => setTimeout(w, ms));\n    } catch (e) {\n        this.log.error(this.err2Str(e));\n        return;\n    }\n}\n\n/**\n * Get previous run of cron job schedule\n * Requires cron-parser\n * Inspired by https://stackoverflow.com/questions/68134104/\n * @param  expression\n * @return milliseconds to previous run (calculated)\n */\nexport function getPreviousCronRun(this: InstanceWatcher, expression: string): number {\n    try {\n        const interval = this.cronParseExpression(expression);\n        const previous = interval.prev();\n        return Math.floor(Date.now() - previous.getTime()); // in ms\n    } catch (e) {\n        this.log.error(this.err2Str(e));\n        return -1;\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0BA,eAAsB,mBAA0C,IAAY,MAA2C;AACnH,MAAI;AAEA,QAAI,KAAK,MAAM,KAAK,IAAI,SAAS,UAAU;AACvC,YAAM,KAAK,qBAAqB,kBAAkB,YAAY,EAAE,KAAK,MAAM,KAAK,MAAM,CAAC;AACvF,WAAK,IAAI,MAAM,oBAAoB,OAAO,KAAK,MAAM,KAAK,IAAI,SAAS,OAAO,gBAAgB,gBAAgB;AAC9G,aAAO;AAAA,IACX,WAAW,KAAK,MAAM,KAAK,IAAI,SAAS,YAAY;AAChD,UAAI,SAAS,SAAS,KAAK,MAAM,KAAK,IAAI,SAAS;AAE/C,cAAM,KAAK,qBAAqB,kBAAkB,YAAY,EAAE,KAAK,OAAO,KAAK,MAAM,CAAC;AACxF,aAAK,IAAI,MAAM,oBAAoB,OAAO,KAAK,MAAM,KAAK,IAAI,mBAAmB;AAAA,MACrF;AACA,UAAI,MAAM;AAEN,YAAI,KAAK,MAAM,KAAK,IAAI;AAAS,gBAAM,KAAK,KAAK,GAAI;AACrD,cAAM,KAAK,qBAAqB,kBAAkB,YAAY,EAAE,KAAK,MAAM,KAAK,MAAM,CAAC;AACvF,aAAK,IAAI,MAAM,oBAAoB,OAAO,KAAK,MAAM,KAAK,IAAI,kBAAkB;AAAA,MACpF;AACA,aAAO;AAAA,IACX,OAAO;AACH,WAAK,IAAI,KAAK,iBAAiB,KAAK,MAAM,KAAK,IAAI,qBAAqB,2BAA2B;AACnG,aAAO;AAAA,IACX;AAAA,EACJ,SAAS,GAAP;AACE,SAAK,IAAI,MAAM,KAAK,QAAQ,CAAC,CAAC;AAC9B,WAAO;AAAA,EACX;AACJ;AAOO,SAAS,QAAQ,OAAoB;AACxC,MAAI,iBAAiB,OAAO;AACxB,QAAI,MAAM;AAAO,aAAO,MAAM;AAC9B,QAAI,MAAM;AAAS,aAAO,MAAM;AAChC,WAAO,KAAK,UAAU,KAAK;AAAA,EAC/B,OAAO;AACH,QAAI,OAAO,UAAU;AAAU,aAAO;AACtC,WAAO,KAAK,UAAU,KAAK;AAAA,EAC/B;AACJ;AASO,SAAS,qBAAqB,MAAoB;AACrD,QAAM,iBAAiB,KAAK,kBAAkB,IAAI;AAClD,SAAO,IAAI,KAAK,KAAK,QAAQ,IAAI,cAAc,EAAE,YAAY,EAAE,MAAM,GAAG,EAAE;AAC9E;AAQO,SAAS,QAAQ,SAA4B;AAChD,MAAI,YAAY,QAAQ,OAAO,YAAY;AAAa,WAAO;AAC/D,MAAI,OAAO,YAAY;AAAY,WAAO;AAC1C,MAAI,IAAI,KAAK,UAAU,OAAO;AAC9B,MAAI,EAAE,QAAQ,QAAQ,EAAE;AACxB,MAAI,EAAE,QAAQ,OAAO,EAAE;AACvB,MAAI,EAAE,QAAQ,OAAO,EAAE;AACvB,MAAI,EAAE,QAAQ,QAAQ,EAAE;AACxB,MAAI,EAAE,QAAQ,QAAQ,EAAE;AACxB,MAAI,EAAE,QAAQ,QAAQ,EAAE;AACxB,MAAI,EAAE,QAAQ,QAAQ,EAAE;AACxB,SAAO,MAAM,KAAK,OAAO;AAC7B;AAOA,eAAsB,KAA4B,IAA2B;AACzE,MAAI;AACA,UAAM,IAAI,QAAQ,CAAC,MAAM,WAAW,GAAG,EAAE,CAAC;AAAA,EAC9C,SAAS,GAAP;AACE,SAAK,IAAI,MAAM,KAAK,QAAQ,CAAC,CAAC;AAC9B;AAAA,EACJ;AACJ;AASO,SAAS,mBAA0C,YAA4B;AAClF,MAAI;AACA,UAAM,WAAW,KAAK,oBAAoB,UAAU;AACpD,UAAM,WAAW,SAAS,KAAK;AAC/B,WAAO,KAAK,MAAM,KAAK,IAAI,IAAI,SAAS,QAAQ,CAAC;AAAA,EACrD,SAAS,GAAP;AACE,SAAK,IAAI,MAAM,KAAK,QAAQ,CAAC,CAAC;AAC9B,WAAO;AAAA,EACX;AACJ;",
  "names": []
}
