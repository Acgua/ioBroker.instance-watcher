{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/**\n * -------------------------------------------------------------------\n *\n *  ioBroker Instance Watcher Adapter\n *\n * @github  https://github.com/Acgua/ioBroker.instance-watcher\n * @forum   https://forum.iobroker.net/topic/XXXXX/\n * @author  Acgua <https://github.com/Acgua/ioBroker.instance-watcher>\n * @created Adapter Creator v2.1.1, on 27 August 2022\n * @license Apache License 2.0\n *\n * -------------------------------------------------------------------\n */\n\n/**\n * For all imported NPM modules, open console, change dir e.g. to \"C:\\iobroker\\node_modules\\ioBroker.instance-watcher\\\",\n * and execute \"npm install <module name>\", ex: npm install cron-parser\n */\nimport * as utils from '@iobroker/adapter-core';\nimport { parseExpression } from 'cron-parser';\nimport { scheduleJob } from 'node-schedule'; // https://github.com/node-schedule/node-schedule\nimport { IInstance } from './lib/interfaces';\nimport { asyncInstanceOnOff, err2Str, getPreviousCronRun, isEmpty, wait } from './lib/methods';\n\n/**\n * Main Adapter Class\n * @class InstanceWatcher\n * Note: 'export' keyword used for \"import { InstanceWatcher } from '../main';\" in lib/methods.ts\n */\nexport class InstanceWatcher extends utils.Adapter {\n    // public to have access from ./lib/methods\n    public _inst = {\n        list: [] as Array<string>, // ['admin.0', 'bring.0', ...]\n        objs: {} as { [k: string]: IInstance }, // {\"admin.0\": {id:.., mode:...}, \"bring.0\": {id:.., mode:...} }\n        notOperating: [] as Array<string>, // List of adapter instances enabled, but not operating, like: ['bring.0', '...']\n    };\n\n    readonly regexValidInstance = /[a-z][a-z0-9\\-_]*.[0-9]{1,2}$/; // to check whether an instance like 'sonos.0' is valid.\n    readonly queueDelay = 1000; // Delay in ms for recursive update function to avoid multiple calls if several calls come in almost the same time.\n\n    // Schedules\n    public schedules = {} as { [k: string]: any };\n\n    // Defined external methods here to access from lib/methods.ts\n    public cronParseExpression = parseExpression;\n    public nodeScheduleScheduleJob = scheduleJob;\n\n    // Imported methods from ./lib/methods\n    public err2Str = err2Str.bind(this);\n    public isEmpty = isEmpty.bind(this);\n    public wait = wait.bind(this);\n    public getPreviousCronRun = getPreviousCronRun.bind(this);\n    public asyncInstanceOnOff = asyncInstanceOnOff.bind(this);\n\n    /**\n     * Constructor\n     */\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({ ...options, name: 'instance-watcher' });\n        this.on('ready', this._asyncOnReady.bind(this));\n        this.on('stateChange', this._asyncOnStateChange.bind(this));\n        this.on('objectChange', this._asyncOnObjectChange.bind(this));\n        this.on('unload', this._onUnload.bind(this));\n    }\n\n    /**\n     * _asyncOnReady\n     * Called once ioBroker databases are connected and adapter received configuration.\n     */\n    private async _asyncOnReady(): Promise<void> {\n        try {\n            // Get info of all ioBroker adapter instances\n            this._inst.objs = await this.asyncGetAllInstancesObjects();\n            if (this.isEmpty(this._inst.objs)) throw 'Failed to get ioBroker adapter instances information.';\n            this._inst.list = Object.keys(this._inst.objs).sort();\n\n            // Create objects/states, if not existing\n            if (!(await this.createObjectsAsync())) throw 'Failed to create objects with createObjectsAsync()';\n\n            // Get initial isOperating and enabled status in _inst.objs\n            for (const id of this._inst.list) {\n                await this._asyncUpdateInstanceInfo(id);\n            }\n\n            // Update States\n            await this.updateOperatingStates('all');\n            for (const id of this._inst.list) {\n                await this.setStateAsync(`instances.${id}.mode`, { val: this._inst.objs[id].mode, ack: true });\n            }\n\n            // Subscribe to state and object changes\n            for (const id of this._inst.list) {\n                // Subscribe to object\n                await this.subscribeForeignObjectsAsync(`system.adapter.${id}`);\n                // Subscribe to foreign states to update on every change\n                await this.subscribeForeignStatesAsync(`system.adapter.${id}.alive`);\n                if (this._inst.objs[id].mode === 'daemon') {\n                    await this.subscribeForeignStatesAsync(`system.adapter.${id}.connected`);\n                    if (this._inst.objs[id].connected_with_device_service !== undefined) {\n                        await this.subscribeForeignStatesAsync(`${id}.info.connection`);\n                    }\n                }\n                // Subscribe to this adapter states in instances, '.enabled', '.on', '.off'\n                await this.subscribeStatesAsync(`instances.${id}.enabled`);\n                await this.subscribeStatesAsync(`instances.${id}.on`);\n                await this.subscribeStatesAsync(`instances.${id}.off`);\n            }\n\n            // Schedule update of schedule instances\n            await this.scheduleScheduleInstancesUpdate();\n\n            // Final message\n            this.log.debug(`${this._inst.list.length} instances initialized: ${JSON.stringify(this._inst.list)}`);\n        } catch (e) {\n            this.log.error(this.err2Str(e));\n            return;\n        }\n    }\n\n    /**\n     * Update instance info.\n     * We use a recursive function to avoid multiple calls.\n     * If called in less than this.queueDelay ms, we wait this.queueDelay +10ms and call function again\n     * @param id - instance id, e.g. 'sonos.0'\n     */\n    private async asyncUpdateQueue(id: string): Promise<void> {\n        try {\n            if (this._inst.objs[id]._noUpdate === true) return;\n            if (this._inst.objs[id]._recentChange >= Date.now() - this.queueDelay) {\n                // Most recent change was less than this.queueDelay ms ago\n                this._inst.objs[id]._noUpdate = true;\n                this._inst.objs[id]._recentChange = Date.now();\n                await this.wait(this.queueDelay + 10); // wait, + 10ms buffer\n                this._inst.objs[id]._noUpdate = false;\n                this.asyncUpdateQueue(id); // call function recursively again\n            } else {\n                // Most recent change was more than this.queueDelay ms ago\n                this._inst.objs[id]._recentChange = Date.now();\n                this._inst.objs[id]._noUpdate = false;\n                // Finally: execute\n                this.log.debug(`asyncUpdateQueue(${id}): Queue completed and update started.`);\n                await this._asyncUpdateInstanceInfo(id);\n                await this.updateOperatingStates(id);\n            }\n        } catch (e) {\n            this.log.error(this.err2Str(e));\n            return;\n        }\n    }\n\n    /**\n     * Schedule the update of schedule instances\n     * TODO: Testen!\n     * After each due schedule of schedule instances, we check if the instance was actually running.\n     */\n    private async scheduleScheduleInstancesUpdate(): Promise<void> {\n        try {\n            for (const id of this._inst.list) {\n                if (this._inst.objs[id].mode !== 'schedule') continue;\n                const rule = this._inst.objs[id].schedule as string;\n                if (!rule || rule.length < 2) {\n                    this.log.error(`No schedule defined for schedule adapter instance ${id}`);\n                    continue;\n                }\n                this.schedules[id] = this.nodeScheduleScheduleJob(rule, async () => {\n                    // Now, the schedule adapter instance is supposed to run.\n                    await this.wait(30 * 1000); // Delay of 30 seconds.\n                    await this.asyncUpdateQueue(id);\n                    this.log.debug(`${id}: ScheduleJob() executed (+30sec) per schedule '${rule}' of this schedule instance.`);\n                });\n            }\n        } catch (e) {\n            this.log.error(this.err2Str(e));\n            return;\n        }\n    }\n\n    /**\n     * Update instance information\n     * @param id - e.g. 'sonos.0'\n     * @returns true if functioning, false if not\n     */\n    private async _asyncUpdateInstanceInfo(id: string): Promise<true | false | undefined> {\n        try {\n            if (!this._inst.objs[id]) throw `Instance ${id} not available in instanceObjects`;\n\n            let isOperating = undefined as true | false | undefined;\n\n            // Status .enabled\n            const obj = await this.getForeignObjectAsync(`system.adapter.${id}`);\n            if (!obj || !obj.common || typeof obj.common.enabled !== 'boolean' || obj.common.enabled === undefined) throw `Could not get common.enabled of object 'system.adapter.${id}'.`;\n            this._inst.objs[id].enabled = obj.common.enabled;\n            isOperating = obj.common.enabled;\n\n            /**\n             * Daemon Adapter Instances\n             */\n            if (this._inst.objs[id].mode === 'daemon') {\n                if (isOperating) {\n                    // Status .alive\n                    const obj = await this.getForeignStateAsync(`system.adapter.${id}.alive`);\n                    if (!obj || obj.val === null || typeof obj.val !== 'boolean' || obj.val === undefined) throw `Could not get state value of 'system.adapter.${id}.alive'.`;\n                    this._inst.objs[id].alive = obj.val;\n                    isOperating = obj.val;\n                    if (isOperating) {\n                        // Status .connected - connected_with_host\n                        const obj = await this.getForeignStateAsync(`system.adapter.${id}.connected`);\n                        if (!obj || obj.val === null || typeof obj.val !== 'boolean' || obj.val === undefined) throw `Could not get state value of 'system.adapter.${id}.connected'.`;\n                        this._inst.objs[id].connected_with_host = obj.val;\n                        isOperating = obj.val;\n                        if (isOperating) {\n                            // Status <name>.<instance>.info.connection - connected_with_device_service\n                            // Note: only certain adapters have this state\n                            if (await this.getForeignObjectAsync(`${id}.info.connection`)) {\n                                // Status info.connection exists\n                                // TODO: Hier noch den Workaround ggf. einbauen!\n                                const obj = await this.getForeignStateAsync(`${id}.info.connection`);\n                                if (!obj || obj.val === null || typeof obj.val !== 'boolean' || obj.val === undefined) throw `Could not get state value of '${id}.info.connection'.`;\n                                this._inst.objs[id].connected_with_device_service = obj.val;\n                                isOperating = obj.val;\n                            }\n                        }\n                    }\n                }\n            } else if (this._inst.objs[id].mode === 'schedule') {\n                if (isOperating) {\n                    const objIsAlive = await this.getForeignStateAsync(`system.adapter.${id}.alive`); // we check the timestamp, which reflects last update\n                    if (!objIsAlive || typeof objIsAlive.ts !== 'number') throw `Could not get timestamp of state 'system.adapter.${id}.alive'.`;\n                    const lastUpdateSecsAgo = Math.floor((Date.now() - objIsAlive.ts) / 1000); // Last update of state in seconds\n                    const sched = this._inst.objs[id].schedule;\n                    if (sched === undefined || sched.length < 1) throw `Could not get schedule of schedule adapter instance '${id}`;\n                    const previousCronRun = this.getPreviousCronRun(sched);\n                    if (previousCronRun === -1) throw `Could not get previous Cron run of schedule adapter instance '${id} for schedule '${sched}'`;\n                    const lastCronRunSecs = Math.floor(previousCronRun / 1000); // if executed at 10:05, \"*/15 * * * *\" would return 5minutes in ms\n                    const diff = lastCronRunSecs - lastUpdateSecsAgo;\n                    isOperating = diff > -300 ? true : false; // We allow 300 seconds (5 minutes) difference\n                }\n            } else {\n                this.log.info(`Instance ${id}: isOperating status for mode '${this._inst.objs[id].mode}' is not yet supported.`);\n                isOperating = false;\n            }\n\n            // Finally\n            this._inst.objs[id].isOperating = isOperating;\n\n            if (!this._inst.objs[id].enabled) {\n                // remove from notOperatingInstances (which only lists enabled adapter instances)\n                this._inst.notOperating = this._inst.notOperating.filter((e) => e !== id); // Removes \"id\", if existing\n                this._inst.notOperating.sort();\n            } else {\n                if (isOperating) {\n                    // remove from notOperatingInstances\n                    this._inst.notOperating = this._inst.notOperating.filter((e) => e !== id);\n                    this._inst.notOperating.sort();\n                } else {\n                    // add to notOperatingInstances\n                    if (!this._inst.notOperating.includes(id)) {\n                        this._inst.notOperating.push(id);\n                        this._inst.notOperating.sort();\n                    }\n                }\n            }\n            return isOperating;\n        } catch (e) {\n            this.log.error(this.err2Str(e));\n            return undefined;\n        }\n    }\n\n    /**\n     * Get info of all ioBroker adapter instances\n     * @returns object with all instance info, like: { \"admin.0\": {id:.., mode:...}, \"bring.0\": {id:.., mode:...} }\n     */\n    private async asyncGetAllInstancesObjects(): Promise<{ [k: string]: IInstance }> {\n        try {\n            // We use getObjectViewAsync() per https://discord.com/channels/743167951875604501/994567327590912010/1011370171564302337\n            // which returns {\"rows\": [{\"id\": \"system.adapter.admin.0\", \"value\": ...}, {\"id\": \"system.adapter.bring.0\", \"value\": ...}\n            const objViewSystemInst = await this.getObjectViewAsync('system', 'instance', null);\n            if (!objViewSystemInst.rows) throw `Error: object.rows of returned object is not defined.`;\n\n            // Handle blacklist from adapter options\n            const blacklist = [];\n            const invalidBl = [];\n            if (this.config.blacklist) {\n                let x = this.config.blacklist;\n                this.log.debug(`Blacklist: From user configuration: ${x}`);\n                x = x.toLowerCase();\n                x = x.replace(/;+/g, ','); // ';' or ';;;' -> ','\n                x = x.replace(/[^0-9a-z-._,]/g, ''); // remove all forbidden chars\n                x = x.replace(/,+/g, ','); // ',,,,' -> ','\n                this.log.debug(`Blacklist: Cleaned: ${x}`);\n                const xArray = x.split(',');\n                for (const itm of xArray) {\n                    if (this.regexValidInstance.test(itm)) {\n                        blacklist.push(itm);\n                    } else {\n                        invalidBl.push(itm);\n                    }\n                }\n            }\n            if (invalidBl.length > 0) this.log.warn(`Blacklist: ${invalidBl.length} invalid ${invalidBl.length > 1 ? 'entries' : 'entry'} in your settings, which will be ignored: ${invalidBl.join(',')}`);\n\n            const returnObj: { [k: string]: IInstance } = {};\n            for (const row of objViewSystemInst.rows) {\n                // Get instance id like 'sonos.0'\n                const instId = row.id.slice(15); // remove 'system.adapter.' to get 'sonos.0'\n                if (!this.regexValidInstance.test(instId)) throw `Instance \"${instId}\" is not valid! - source id: \"${row.id}\"`;\n                if (!row.value || !row.value.common) throw `row.value of instance ${instId} is not defined.`;\n                if (instId === this.namespace) continue; // do not include instance-watcher.x as it would not make sense\n                if (!['daemon', 'schedule'].includes(row.value.common.mode)) continue; // We only cover daemon and schedule instances\n                if (blacklist.includes(instId)) {\n                    this.log.debug(`Blacklist: Instance ${instId} successfully ignored per blacklist settings.`);\n                    continue;\n                }\n\n                // Get objects\n                returnObj[instId] = {\n                    id: instId, // 'sonos.0',\n                    mode: row.value.common.mode, // daemon, schedule, etc.\n                    enabled: row.value.common.enabled, // if instance is enabled in ioBroker admin\n                    // @ts-expect-error - Property \"schedule\" for type \"InstanceCommon\" is actually existing if mode=schedule. \u2013 ts(2339)\n                    schedule: row.value.common.mode === 'schedule' && row.value.common.schedule ? row.value.common.schedule : undefined,\n                    _recentChange: Date.now(),\n                    _noUpdate: false,\n                };\n            }\n            if (this.isEmpty(returnObj)) throw 'Error getting instance objects: No adapter instance found within ioBroker!';\n            return returnObj;\n        } catch (e) {\n            this.log.error(this.err2Str(e));\n            return {};\n        }\n    }\n\n    /**\n     * Updating states\n     * @param what - 'all': update all; '<instance id>' like 'sonos.0': Update specific instance only\n     */\n    private async updateOperatingStates(what: string): Promise<void> {\n        try {\n            await this.setStateAsync('info.notOperatingList', { val: JSON.stringify(this._inst.notOperating), ack: true });\n            await this.setStateAsync('info.notOperatingCount', { val: this._inst.notOperating.length, ack: true });\n            await this.setStateAsync('info.updatedDate', { val: Date.now(), ack: true });\n\n            let list: Array<string> = [];\n            if (what === 'all') {\n                list = this._inst.list;\n            } else if (this._inst.list.includes(what)) {\n                list.push(what); // e.g. 'sonos.0'\n            } else {\n                throw `Given parameter '${what}' is not valid!`;\n            }\n\n            for (const id of list) {\n                await this.setStateAsync(`instances.${id}.isOperating`, { val: this._inst.objs[id].isOperating, ack: true });\n                await this.setStateAsync(`instances.${id}.enabled`, { val: this._inst.objs[id].enabled, ack: true });\n                if (this._inst.objs[id].enabled) {\n                    await this.setStateAsync(`instances.${id}.on`, { val: true, ack: true });\n                    await this.setStateAsync(`instances.${id}.off`, { val: false, ack: true });\n                } else {\n                    await this.setStateAsync(`instances.${id}.on`, { val: false, ack: true });\n                    await this.setStateAsync(`instances.${id}.off`, { val: true, ack: true });\n                }\n            }\n        } catch (e) {\n            this.log.error(this.err2Str(e));\n            return;\n        }\n    }\n\n    /**\n     * Called once a subscribed object changes. Initialized by Class constructor.\n     * At this time, we only handle 'system.adapter.*.0' objects\n     * TODO: We may also want to handle a change of the mode. This is very unlikely, though.\n     *       We could also handle a deletion/removal of an adapter instance here: if !obj, then object was deleted.\n     *  @param objId - e.g. 'system.adapter.sonos.0'\n     *  @param obj - updated object\n     */\n    private async _asyncOnObjectChange(objId: string, obj: ioBroker.Object | null | undefined): Promise<void> {\n        try {\n            if (!obj) return;\n\n            const idParts = objId.split('.');\n            const id = idParts[2] + '.' + idParts[3]; // e.g. 'sonos.0'\n            if (!this._inst.list.includes(id)) throw `Determined instance id '${id}' not valid!`;\n            const new_enabled = obj.common.enabled;\n            const new_schedule = obj.common.schedule;\n\n            // Update enabled and isOperating etc.\n            if (new_enabled === undefined) throw `Unable to get common.enabled of object ${objId}`;\n            if (new_enabled !== this._inst.objs[id].enabled) {\n                // Update variables, and states\n                await this.asyncUpdateQueue(id);\n            }\n\n            // Update schedule, if changed\n            if (this._inst.objs[id].mode === 'schedule' && new_schedule !== undefined && new_schedule.length > 0) {\n                if (this._inst.objs[id].schedule !== new_schedule) {\n                    this._inst.objs[id].schedule = new_schedule;\n                    await this.setStateAsync(`instances.${id}.schedule`, { val: new_schedule, ack: true });\n                }\n            }\n        } catch (e) {\n            this.log.error(this.err2Str(e));\n            return;\n        }\n    }\n\n    /**\n     * Called once a subscribed state changes. Initialized by Class constructor.\n     *  @param stateId - e.g. \"instance-watcher.0.instances.sonos.0.on\"\n     *  @param stateObj - e.g. { val: true, ack: false, ts: 123456789, q: 0, lc: 123456789 }\n     */\n    private async _asyncOnStateChange(stateId: string, stateObj: ioBroker.State | null | undefined): Promise<void> {\n        try {\n            if (!stateObj) return;\n            const stateIdElements = stateId.split('.');\n\n            /**\n             * .on / .off / .enabled\n             */\n            if (stateObj.ack === false && stateId.startsWith(this.namespace) && (stateId.endsWith('.on') || stateId.endsWith('.off') || stateId.endsWith('.enabled'))) {\n                this.log.debug(`${stateId} set to '${stateObj.val}' (ack:false) by user.`);\n                const idParts = stateId.split('.');\n                const id = idParts[3] + '.' + idParts[4]; // e.g. 'sonos.0'\n                if (!this._inst.list.includes(id)) throw `Determined instance id '${id}' not valid!`;\n\n                let flag = undefined;\n                if (stateId.endsWith('.on') && stateObj.val) flag = true;\n                if (stateId.endsWith('.on') && !stateObj.val) flag = false;\n                if (stateId.endsWith('.off') && stateObj.val) flag = false;\n                if (stateId.endsWith('.off') && !stateObj.val) flag = true;\n                if (stateId.endsWith('.enabled')) flag = stateObj.val;\n\n                if (flag === true || flag === false) await this.asyncInstanceOnOff(id, flag);\n            }\n\n            /**\n             * system.adapter.<adapter-name>.<instance>.alive\n             */\n            if (stateId.endsWith('.alive') && stateObj.ack === true) {\n                const id = stateIdElements[2] + '.' + stateIdElements[3]; // 'sonos.0'\n                const oldValue = this._inst.objs[id].alive;\n                if (oldValue === stateObj.val) return; // No change!\n                await this.asyncUpdateQueue(id); // Update info and states\n            }\n\n            /**\n             * system.adapter.<adapter-name>.<instance>.connected\n             */\n            if (stateId.endsWith('.connected') && stateObj.ack === true) {\n                const id = stateIdElements[2] + '.' + stateIdElements[3]; // 'sonos.0'\n                const oldValue = this._inst.objs[id].connected_with_host;\n                if (oldValue === stateObj.val) return; // No change!\n                await this.asyncUpdateQueue(id); // Update info and states\n            }\n\n            /**\n             * <adapter-name>.<instance>.info.connection\n             */\n            if (stateId.endsWith('.info.connection') && stateObj.ack === true) {\n                const id = stateIdElements[0] + '.' + stateIdElements[1]; // 'sonos.0'\n                const oldValue = this._inst.objs[id].connected_with_device_service;\n                if (oldValue === stateObj.val) return; // No change!\n                await this.asyncUpdateQueue(id); // Update info and states\n            }\n        } catch (e) {\n            this.log.error(this.err2Str(e));\n            return;\n        }\n    }\n\n    /**\n     * Create objects\n     * @returns true if successful, false if not\n     */\n    private async createObjectsAsync(this: InstanceWatcher): Promise<true | false> {\n        try {\n            // Creating main channel and state objects\n            await this.setObjectNotExistsAsync('instances', { type: 'channel', common: { name: 'ioBroker adapter instances' }, native: {} });\n            await this.setObjectNotExistsAsync('info', { type: 'channel', common: { name: 'All adapter instances' }, native: {} });\n            await this.setObjectNotExistsAsync('info.notOperatingCount', { type: 'state', common: { name: 'Counter: Enabled but not functioning instances', type: 'number', role: 'info', read: true, write: false, def: 0 }, native: {} });\n            await this.setObjectNotExistsAsync('info.notOperatingList', { type: 'state', common: { name: 'List: Enabled but not functioning instances', type: 'array', role: 'info', read: true, write: false, def: '[]' }, native: {} });\n            await this.setObjectNotExistsAsync('info.updatedDate', { type: 'state', common: { name: 'Last update', type: 'number', role: 'date', read: true, write: false, def: 0 }, native: {} });\n\n            // Create adapter instance device and state objects\n            for (const id of this._inst.list) {\n                const path = 'instances.' + id;\n                await this.setObjectNotExistsAsync(path, { type: 'device', common: { name: 'Instance ' + id }, native: {} });\n                await this.setObjectNotExistsAsync(path + '.mode', { type: 'state', common: { name: 'Running mode (none, daemon, subscribe, schedule, once, extension)', type: 'string', role: 'info', read: true, write: false }, native: {} });\n                await this.setObjectNotExistsAsync(path + '.isOperating', { type: 'state', common: { name: 'Successfully operating', type: 'boolean', role: 'info', read: true, write: false }, native: {} });\n                await this.setObjectNotExistsAsync(path + '.on', { type: 'state', common: { name: 'Switch instance on (or restart, if running).', type: 'boolean', role: 'button', read: true, write: true }, native: {} });\n                await this.setObjectNotExistsAsync(path + '.off', { type: 'state', common: { name: 'Switch instance off.', type: 'boolean', role: 'button', read: true, write: true }, native: {} });\n                await this.setObjectNotExistsAsync(path + '.enabled', { type: 'state', common: { name: 'Enable status of instance. You can switch instance on/off with this state', type: 'boolean', role: 'switch', read: true, write: true }, native: {} });\n            }\n\n            /**\n             * Cleanup: Delete objects no longer required, e.g., if user has uninstalled an adapter instance\n             */\n            // Get string array of all adapter objects: ['instance-watcher.0.info', 'instance-watcher.0.Instances.admin_0', ...];\n            const paths = Object.keys(await this.getAdapterObjectsAsync());\n\n            // Get all instance ids of 'instance-watcher.0.instances...', like ['admin.0', 'bring.0', ...]\n            const allIds: Array<string> = [];\n            for (const path of paths) {\n                const pathSplit = path.split('.');\n                if (pathSplit[2] === 'instances' && pathSplit[3]) {\n                    const id = pathSplit[3] + '.' + pathSplit[4]; // e.g. 'sonos.0'\n                    if (!allIds.includes(id)) allIds.push(id);\n                }\n            }\n            // Delete instance objects if adapter instance is no longer available/installed\n            for (const id of allIds) {\n                if (!this._inst.list.includes(id)) {\n                    await this.delObjectAsync('instances.' + id, { recursive: true });\n                    this.log.info(`Cleanup: Deleted no longer available instance states of '${id}'.`);\n                }\n            }\n            return true;\n        } catch (e) {\n            this.log.error(this.err2Str(e));\n            return false;\n        }\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private _onUnload(callback: () => void): void {\n        try {\n            // Here you must clear all timeouts or intervals that may still be active\n            // clearTimeout(timeout1);\n            // clearInterval(interval1);\n\n            /**\n             * Clear all Schedules\n             */\n            let scheduleCounter = 0;\n            for (const scheduleName in this.schedules) {\n                if (this.schedules[scheduleName]) {\n                    this.log.debug('Cancelling schedule for ' + scheduleName);\n                    this.schedules[scheduleName].cancel();\n                    scheduleCounter++;\n                }\n            }\n            this.log.info(`(${scheduleCounter}) schedules cleared...`);\n\n            callback();\n        } catch (e) {\n            callback();\n        }\n    }\n}\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new InstanceWatcher(options);\n} else {\n    // otherwise start the instance directly\n    (() => new InstanceWatcher())();\n}\n"],
  "mappings": "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",
  "names": ["obj"]
}
